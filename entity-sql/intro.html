<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>entity-sql</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Entity-sql</span> <span class="project-version">0.1.1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="intro.html"><div class="inner"><span>entity-sql</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="entity.sql.hug.html"><div class="inner"><span>entity.sql.hug</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong> <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p>
<ul>
  <li><a href="#entity-sql">entity-sql</a>
    <ul>
      <li><a href="#basics">Basics</a></li>
      <li><a href="#sql-and-keys">SQL and Keys</a>
        <ul>
          <li><a href="#select-statement">Select Statement</a></li>
          <li><a href="#primary-key">Primary Key</a></li>
          <li><a href="#other-keys">Other Keys</a></li>
          <li><a href="#support-for-multiple-vendors">Support for Multiple Vendors</a></li>
          <li><a href="#updating">Updating</a></li>
          <li><a href="#deletion">Deletion</a></li>
        </ul>
      </li>
      <li><a href="#making-connections">Making Connections</a></li>
      <li><a href="#usage">Usage</a></li>
    </ul>
  </li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1><a href="#entity-sql" name="entity-sql"></a>entity-sql</h1>
<p>Provides SQL persistence for entities defined with <a href="https://github.com/inqwell/entity-core"><code>entity-core</code></a> using <a href="https://www.hugsql.org"><code>HugSQL</code></a>. For further explanation of the terms <em>snippets</em> … please see the HugSQL documentation.</p>
<p>The goal is to support a common, reusable select statement and to provide support for database vendor independence. Database connections are pooled using HikariCP.</p>
<h2><a href="#basics" name="basics"></a>Basics</h2>
<p>The concept defined by <code>entity-core</code> is that any persistence mechanism will provide instances of that entity and that entity only. If ‘joins’ are required these are achieved by placing the related entity (or collection of entities if the relationship is 1:many) in a suitable data structure, with their positions implying the relationship.</p>
<p>For example, a <code>Fruit</code> may have many <code>Supplier</code>s. A suitable structure expressing this relationship might be:</p>
<pre><code class="clojure">{:Fruit f
 :suppliers
 [{:Supplier s} {:Supplier s} ... ]}
</code></pre>
<p>If a <code>Fruit</code> has one <code>NutritionInfo</code> then this structure could express that relationship like this:</p>
<pre><code class="clojure">{:Fruit f :NutritionInfo n
 :suppliers
 [{:Supplier s} {:Supplier s} ... ]}
</code></pre>
<p>These structures are a matter for domain-level code.</p>
<h2><a href="#sql-and-keys" name="sql-and-keys"></a>SQL and Keys</h2>
<p>Each entity requires a <code>HugSQL</code> file structured in a certain way.</p>
<h3><a href="#select-statement" name="select-statement"></a>Select Statement</h3>
<p>The file must contain a snippet called <code>select-stmt</code> as in this example</p>
<pre><code class="SQL">-- Fruit

-- :snip select-stmt
SELECT
 F.Fruit          AS "Fruit",
 F.Description    AS "Description",
 F.ShelfLife      AS "ShelfLife",
 F.Active         AS "Active",
 F.Freezable      AS "Freezable"
FROM Fruit F
</code></pre>
<h3><a href="#primary-key" name="primary-key"></a>Primary Key</h3>
<p>The query by the entity’s primary key must be called <code>primary</code> like so:</p>
<pre><code class="SQL">-- :name primary :? :1
:snip:select-stmt
WHERE F.Fruit   = :Fruit
</code></pre>
<p>Notice it uses the <code>select-stmt</code> snippet defined earlier.</p>
<h3><a href="#other-keys" name="other-keys"></a>Other Keys</h3>
<p>Other keys are defined similarly, for example:</p>
<pre><code class="sql">-- :name by-freezable :? :*
:snip:select-stmt
WHERE F.Freezable = :Freezable
</code></pre>
<p>Note that a key’s uniqueness must be reflected in the HugSQL result type: a unique key should have a result type of <code>:1</code> and a non-unique one a result type of <code>:*</code>.</p>
<p>Note also the function name must be the same as the key name used in the <code>entity-core</code> definition.</p>
<h3><a href="#support-for-multiple-vendors" name="support-for-multiple-vendors"></a>Support for Multiple Vendors</h3>
<p>A SQL connection and a file of SQL statements are connected using <code>bind-connection</code>. This macro includes three sets of options. The set <code>entity-opts</code> are merged with the parameter map passed to the generated HugSQL functions, making them available for use in the SQL file.</p>
<p>Let’s say you have developed your schema under one database vendor, only to find a frequently used column name is a reserved word when porting to another, eg:</p>
<pre><code class="sql">-- :snip select-stmt
SELECT
 F.Fruit          AS "Fruit",
 F.Description    AS "Description",
 F.ShelfLife      AS "ShelfLife",
 F.Active         AS "Active",
 F.Freezable      AS "Freezable",
/*~
(if (= (:server-type params) :oracle)
 "F.User_"
 "F.User")
~*/ AS "User"
FROM Fruit F
</code></pre>
<p>By including the parameter <code>:server-type</code> in <code>entity-opts</code> it can be used, in this case, within a Clojure expression (see HugSQL documentation for further details).</p>
<h3><a href="#updating" name="updating"></a>Updating</h3>
<p>To write an entity instance, all fields must be written, and the function must be called <code>:write</code>. Here is an example, taking into account vendor variations:</p>
<pre><code class="sql">-- :name write :! :n
/*~
(condp = (:server-type params)
 :mysql "
REPLACE Fruit
SET
    Fruit           = :Fruit,
    Description     = :Description,
    ShelfLife       = :ShelfLife,
    Active          = :Active,
    Freezable       = :Freezable
    User            = :User"
 :oracle "
MERGE INTO Fruit USING DUAL
ON (Fruit   = :Fruit)
WHEN MATCHED THEN
    UPDATE SET
        Description     = :Description,
        ShelfLife       = :ShelfLife,
        Active          = :Active,
        Freezable       = :Freezable
        User            = :User"
WHEN NOT MATCHED THEN
INSERT
(
    Fruit,
    Description,
    ShelfLife,
    Active,
    Freezable,
    User_
)
VALUES
(
    :Fruit,
    :Description,
    :ShelfLife,
    :Active,
    :Freezable,
    :User
)")
~*/
</code></pre>
<h3><a href="#deletion" name="deletion"></a>Deletion</h3>
<p>Deletion is optional, but if supported the HugSQL function must be called <code>:delete</code>:</p>
<pre><code class="sql">-- :name delete :! :n
DELETE FROM Fruit F
WHERE F.Fruit   = :Fruit
</code></pre>
<h2><a href="#making-connections" name="making-connections"></a>Making Connections</h2>
<p>In Clojure JDBC a ‘connection’ is only a map containing various keys. If these keys only describe a URL, user and password a connection to the underlying database will be made for each query. entity-sql supplies the <code>:datasource</code> key using HikariCP as the connection pool.</p>
<h2><a href="#usage" name="usage"></a>Usage</h2>
<p>Not presently hosted. Use <code>lein install</code> to place in your local maven repo for now and use the version found in <code>project.clj</code> for your dependency.</p></div></div></div></body></html>