<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>entity-txn</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Entity-txn</span> <span class="project-version">0.1.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="intro.html"><div class="inner"><span>entity-txn</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>entitytxn</span></div></div></li><li class="depth-2 branch"><a href="entitytxn.aggregate.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aggregate</span></div></a></li><li class="depth-2 branch"><a href="entitytxn.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="entitytxn.entity.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>entity</span></div></a></li><li class="depth-2 branch"><a href="entitytxn.lock.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lock</span></div></a></li><li class="depth-2"><a href="entitytxn.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong> <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p>
<ul>
  <li><a href="#entity-txn">entity-txn</a>
    <ul>
      <li><a href="#identity">Identity</a></li>
      <li><a href="#opening-a-transaction">Opening a Transaction</a></li>
      <li><a href="#setting-transaction-defaults">Setting Transaction Defaults</a></li>
    </ul>
  </li>
  <li><a href="#instance-lifecycle">Instance Lifecycle</a>
    <ul>
      <li><a href="#managed-instances">Managed Instances</a></li>
      <li><a href="#make-new-instance">make-new-instance</a></li>
      <li><a href="#create">create</a></li>
      <li><a href="#in-creation">in-creation?</a></li>
      <li><a href="#delete">delete</a></li>
      <li><a href="#assoc-and-merge">assoc and merge</a></li>
      <li><a href="#state-transitions">State Transitions</a></li>
      <li><a href="#nested-transactions">Nested Transactions</a></li>
    </ul>
  </li>
  <li><a href="#transaction-cycle">Transaction Cycle</a>
    <ul>
      <li><a href="#do-on-start">:do-on-start</a></li>
      <li><a href="#body">body</a></li>
      <li><a href="#commit">commit</a></li>
      <li><a href="#abort">abort</a></li>
      <li><a href="#do-on-end">:do-on-end</a></li>
    </ul>
  </li>
  <li><a href="#locks">Locks</a></li>
  <li><a href="#entity-foo">entity-foo</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1><a href="#entity-txn" name="entity-txn"></a>entity-txn</h1>
<p>entity-txn is a simple library that manages the state of domain type instances, which are maps or records, during a set of CRUD operations as a transaction. It requires the following</p>
<ul>
  <li>a golden source/sink for domain instances</li>
  <li>a type system that supports identity and lifecycle events</li>
</ul>
<p>A protocol is provided to make these connections, and the library comes with an implementation that bridges to entity-core.</p>
<p>Of course, it’s not very Clojure-like to <em>update</em> or <em>delete</em> things, but there are a lot of such applications out there and how you implement your domain model is up to you, for example accretion of rows instead of deletion. There are places in <code>entity-txn</code> where you can veto deletion, either globally or on a per-type basis.</p>
<h2><a href="#identity" name="identity"></a>Identity</h2>
<p>Each domain type must define its identity. This is one or more of the map values from from an instance. Additionally, there must be included something that makes the identity unique across all domain types. For example, if we have two types, <code>Fruit</code> and <code>Nutrition</code>, instances might be:</p>
<pre><code class="clojure">:foo/Fruit ; Fruit type
{:Fruit       "Strawberry"           ; identity field
 :Description "Soft Summer Fruit"
 :ShelfLife   14}

:foo/Nutrition ; Nutrition type
{:Fruit       "Strawberry"           ; identity field
 :KCalPer100g 28
 :Fat         0
 :Salt        0}
</code></pre>
<p>Both types define their identity as the <code>:Fruit</code> field. The type system must provide some meta data to resolve this ambiguity, so the respective identities could look like</p>
<pre><code class="clojure">{:Fruit       "Strawberry"           ; identity field
 :entity      :foo/Fruit}
</code></pre>
<p>and</p>
<pre><code>{:Fruit       "Strawberry"           ; identity field
 :entity      :foo/Nutrition}
</code></pre>
<h2><a href="#opening-a-transaction" name="opening-a-transaction"></a>Opening a Transaction</h2>
<p>Use the <code>in-transaction</code> macro, supplying transaction arguments and body:</p>
<pre><code class="clojure">(in-transaction
  {:on-commit my-fn}
  ( ... ))
</code></pre>
<h2><a href="#setting-transaction-defaults" name="setting-transaction-defaults"></a>Setting Transaction Defaults</h2>
<p>Use <code>set-transaction-defaults</code> during startup to avoid supplying transaction arguments on each use, for example:</p>
<pre><code class="clojure">(set-transaction-defaults
  :events (entity-txn-events)   ; use entity-core as domain type system
  :on-commit (fn [participants actions] ; write the participating instances to the DB using a DB transaction
               (sql/with-transaction [*fruit-db*]
                                     (write-txn-state participants)))))
</code></pre>
<p>See the api documentation for a full ilst of options.</p>
<h1><a href="#instance-lifecycle" name="instance-lifecycle"></a>Instance Lifecycle</h1>
<h2><a href="#managed-instances" name="managed-instances"></a>Managed Instances</h2>
<p>Instances are obtained from the golden source by <code>(read-instance ...)</code>. Such instances are marked as <em>managed</em>. <code>entity-txn</code> provides the vars <code>assoc</code> and <code>merge</code> that maintain the original state of the instance and its current state within the transaction. Using these functions the latest state of any instance is maintained in the transaction ready for commit. Note that <code>read-instance</code> will include the current state of any instance presently mutated or deleted in the transaction: mutated intances will return the present value and deleted instances will be excluded.</p>
<p>Instances are only managed when obtained inside a transaction. Otherwise <code>read-entity</code> returns results from the golden source unmodified, <code>assoc</code> and <code>merge</code> operate without affecting transaction state and <code>delete</code> will throw.</p>
<h2><a href="#make-new-instance" name="make-new-instance"></a>make-new-instance</h2>
<p>Use this function to create candidate instances that can be placed in the transaction using <code>create</code>. Arguments will specify the domain type and any initial value.</p>
<h2><a href="#create" name="create"></a>create</h2>
<p>Use <code>create</code> to mark the instance for creation in the transaction. The type system has the opportunity to validate, further initialise or create further instances, presumably related in the domain model.</p>
<h2><a href="#in-creation-" name="in-creation-"></a>in-creation?</h2>
<p>It is an error to create the same identity twice. Use <code>in-creation?</code> passing an instance or its identity if it is necessary to check for this amongst a sequence of instances being processed.</p>
<h2><a href="#delete" name="delete"></a>delete</h2>
<p>This function will mark the instance for deletion. The type system is notified the instance is being deleted and can, for example, delete related instances.</p>
<h2><a href="#assoc-and-merge" name="assoc-and-merge"></a>assoc and merge</h2>
<p>These functions will, on first use, record the original value and any subsequent changes as the current value in the transaction. See further below for interaction with the type system.</p>
<h2><a href="#state-transitions" name="state-transitions"></a>State Transitions</h2>
<p>Transaction state management allows the following</p>
<ul>
  <li>Create and delete the same thing - nothing happens</li>
  <li>Delete and create the same thing - delete followed by create in the golden sink</li>
  <li>Delete, create, delete - delete the original instance in the golden sink</li>
</ul>
<h2><a href="#nested-transactions" name="nested-transactions"></a>Nested Transactions</h2>
<p>Transactions can be nested, and only the state in the current transaction is committed when it closes. If a child transaction performs <code>read-instance</code> and the results include state held in any ancestor then this state will be represented, however it is not permitted to further manipulate such instances in the current transaction.</p>
<h1><a href="#transaction-cycle" name="transaction-cycle"></a>Transaction Cycle</h1>
<p>The stages of transaction execution are:</p>
<h2><a href="#do-on-start" name="do-on-start"></a>:do-on-start</h2>
<p>A function of zero arguments called before execution of the body. This may be used, for example, to arbitrate for locks.</p>
<h2><a href="#body" name="body"></a>body</h2>
<p>Execute the body</p>
<h2><a href="#commit" name="commit"></a>commit</h2>
<p>If no exception is thrown in the body, a transaction enters the commit phase.</p>
<p>The type system is informed of each mutation, passing the original and current values. It then has a chance to perform any further domain value changes, for example for reasons of domain model constraints, silently veto the change by returning the old value, or veto the entire transaction by throwing. If further state is entered into the transaction by this means this process continues until there are no new participants.</p>
<p>Then, call the <code>:on-commit</code> function, passing the accumulated participants and their actions. These arguments are maps:</p>
<pre><code class="clojure">participants -&gt; {&lt;identity&gt; &lt;value&gt;}
actions      -&gt; {&lt;identity&gt; &lt;action&gt;}
</code></pre>
<p>The action is one of <code>:create</code>, <code>:mutate</code> or <code>:delete</code>. The value is the instance or, in the case of <code>:mutate</code> a map containing <code>{:old-val &lt;original&gt; :new-val &lt;current&gt;}</code>. A convenience function <code>write-txn-state</code> will perform all actions to the golden sink, as in the example, above.</p>
<h2><a href="#abort" name="abort"></a>abort</h2>
<p>If an exception occurs in the transaction body, all transaction state is discarded and any <code>:on-abort</code> function is called.</p>
<h2><a href="#do-on-end" name="do-on-end"></a>:do-on-end</h2>
<p>If held, this function will be called whether the transaction was committed or aborted.</p>
<h1><a href="#locks" name="locks"></a>Locks</h1>
<p>The library includes a simple lock manager. If, for example, a transaction wishes to gain exclusive access according to some domain value, <code>:do-on-start</code> might be</p>
<pre><code class="clojure">(entitytxn.lock/lock some-value)
</code></pre>
<p>The lock manager can be used directly, in which case locks are not part of transaction state. Locks taken out as above will be automatically released when the transaction closes.</p>
<h1><a href="#entity-foo" name="entity-foo"></a>entity-foo</h1>
<p>By now it will be clear that <code>entity-txn</code> and the other <code>entity-...</code> libraries are aimed at bringing domain types, model management and I/O into the Clojure functional world. See <a href="https://github.com/inqwell/entity-core"><code>entity-core</code></a> and <a href="https://github.com/inqwell/entity-sql"><code>entity-sql</code></a> for further details</p>
<p>Often, many type instances must be brought together in a nested structure to support some particular processing. This task is accomplished by <code>entity-core</code>’s <code>aggregate</code> function and to ensure such instances are managed, there is <code>entitytxn.aggregate/aggregate</code>.</p>
<p>If you are not using entity-core and instead providing your own type system, you might find it useful to provide your own such function. This is quite straightforward to do, for example using the excellent <a href="https://github.com/nathanmarz/specter"><code>specter</code></a> library.</p></div></div></div></body></html>