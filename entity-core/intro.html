<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>entity-core</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Entity-core</span> <span class="project-version">0.1.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="intro.html"><div class="inner"><span>entity-core</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>entity</span></div></div></li><li class="depth-2 branch"><a href="entity.aggregate.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aggregate</span></div></a></li><li class="depth-2 branch"><a href="entity.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="entity.protocol.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocol</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#entity-core" name="entity-core"></a>entity-core</h1>
<p>A Clojure library for defining domain types, their keys and persistence bindings. Can be used with <a href="https://github.com/inqwell/entity-sql"><code>entity-sql</code></a> when the persistence mechanism is a SQL database. Uses <a href="https://github.com/inqwell/typeops"><code>typeops</code></a> to maintain purity of domain type instances.</p>
<p>Types are denoted by name-spaced keywords; scalars, enums and entities are supported.</p>
<p>See also <a href="https://github.com/inqwell/entity-txn"><code>entity-txn</code></a> for lifecycle management and transactions</p>
<h2><a href="#define-scalars" name="define-scalars"></a>Define Scalars</h2>
<pre><code class="clojure">(ns fruits.model.common
  (require [entity.core :refer :all]))

(defscalar :fin/Money 0.00M)   ; type is decimal accurate to 2dp
=&gt; :fin/Money

(defscalar :foo/LongName "")   ; type is string
=&gt; :foo/LongName

(defscalar :foo/NumDays 0)     ; type is long
=&gt; :foo/NumDays

(defscalar :foo/DateTime (java.util.Date.))
=&gt; :foo/DateTime
</code></pre>
<h2><a href="#define-enums" name="define-enums"></a>Define Enums</h2>
<p>Enums define keyword to value mappings and a default value</p>
<pre><code class="clojure">(defenum :foo/Freezable {:y "Y"
                         :n "N"} :y)

(defenum :foo/Active {:y 1
                      :n 0} :y)
</code></pre>
<h2><a href="#define-entities" name="define-entities"></a>Define Entities</h2>
<pre><code class="clojure">(ns fruits.model.fruit
  (require [fruits.model.common] ; drag in common types
           [fruits.model.config :refer [*fruit-db* fruit-db-opts]]
           [entity.sql.hug :as sql]
           [entity.core :refer :all]))

(defentity :foo/Fruit
           [Fruit          ""
            Description    :foo/LongName = nil
            ShelfLife      :foo/NumDays
            Active         (enum-val :foo/Active :y)
            Freezable      (enum-val :foo/Freezable :n)]
           [Fruit]
           :keys {:all          {:unique? false
                                 :cached? true
                                 :fields  []}
                  :by-freezable {:unique? false
                                 :cached? true
                                 :fields  [Freezable]}
                  :filter       {:unique? false
                                 :cached? false
                                 :fields  [Fruit
                                           Active :as FruitActive]}}
           :io (sql/bind-connection *fruit-db* "sql/fruit.sql" fruit-db-opts)
           :create (fn [instance] (comment stuff))
           :mutate (fn [old new] (comment stuff))
           :join (fn [instance] (comment stuff))
           :destroy (fn [instance] (comment stuff)))
</code></pre>
<p>The fields of an entity is a vector of names and types (or values that infer the type), with an optional default value. If no default value is present the field takes the value of the type reference. Values (inferring the type or the default) can be a literal, reference to a scalar or an expression.</p>
<p>Every entity must have a primary key, which defines its uniqueness in the application domain. This is a vector whose content must be names of fields the entity defines. All other elements are optional.</p>
<p>An entity is implemented as a record: <code>(defentity ...)</code> will emit <code>(defrecord ...)</code> for the specified fields.</p>
<h2><a href="#defining-keys" name="defining-keys"></a>Defining Keys</h2>
<p>Any number of additonal keys, unique or otherwise, can be defined using the <code>:keys</code> argument. This is a map defining the fields, uniqueness and cached status of each key</p>
<blockquote>
  <p>NOTE: <code>unique?</code> and <code>cached?</code> are not presently used.</p>
</blockquote>
<p>The example above defines the key <code>:filter</code> as having two fields, both native to the entity. <code>Active</code> is renamed in the key as <code>FruitActive</code>. This is to cater for those cases where the underlying retrieval mechanism joins between entities that both define a field called <code>Active</code>. Consider the following example:</p>
<p><img src="er.png" alt="ER Diagram" title="Entity/Relationship Diagram" /></p>
<p>Perhaps we want to define a <code>:filter</code> key to support queries for <code>FruitSupplier</code> instances, wild-carding the fruit and supplier, according to whether a fruit and supplier is active and whether an order was placed in a particular date range. This would be declared like so:</p>
<pre><code class="clojure">           :keys {
                    .
                    .
                  :filter {:unique? false
                           :cached? false
                           :fields  [Fruit
                                     Supplier
                                     :foo/Fruit.Active :as FruitActive
                                     :foo/Supplier.Active :as :SupplierActive
                                     LastOrdered :as FromDate
                                     LastOrdered :as ToDate
                                     :foo/Fruit.Freezable
                                     :foo/Fruit.ShelfLife :as MinShelfLife
                                     :foo/Fruit.ShelfLife :as MaxShelfLife]}
</code></pre>
<p>The SQL to apply this key could be:</p>
<pre><code class="sql">SELECT
 FS.Fruit          AS "Fruit",
 FS.Supplier       AS "Supplier",
 FS.PricePerKg     AS "PricePerKg",
 FS.LastOrdered    AS "LastOrdered"
FROM FruitSupplier FS,
Fruit F,
Supplier S
WHERE F.Fruit = FS.Fruit
AND   S.Supplier = FS.Supplier
AND (FS.Fruit = :Fruit OR :Fruit IS NULL)
AND (FS.Supplier = :Supplier OR :Supplier IS NULL)
AND (F.ShelfLife &gt;= :MinShelfLife OR :MinShelfLife IS NULL)
AND (F.ShelfLife &lt;= :MaxShelfLife OR :MaxShelfLife IS NULL)
AND (F.Active = :FruitActive OR :FruitActive IS NULL)
AND (S.Active = :SupplierActive OR :SupplierActive IS NULL)
AND (F.Freezable = :Freezable OR :Freezable IS NULL)
AND (FS.LastOrdered &gt;= :FromDate OR :FromDate IS NULL)
AND (FS.LastOrdered &lt;= :ToDate OR :ToDate IS NULL)
</code></pre>
<p>All keys, including the <code>:primary</code>, return instances of the entity only. Any aggregations with other domain data types should be expressed by associating related instance(s) via their position in a dynamically constructed data graph.</p>
<p>By default, key field values are nil. <code>typeops</code> is used to enforce the correct types for field values set its definition of <code>assoc</code>.</p>
<pre><code class="clojure">(make-key
    :foo/FruitSupplier
    :filter
    {})
=&gt;
{:ToDate nil,
 :MaxShelfLife nil,
 :Freezable nil,
 :MinShelfLife nil,
 :Supplier nil,
 :FruitActive nil,
 :SupplierActive nil,
 :Fruit nil,
 :FromDate nil}
</code></pre>
<p>In order for the types to be known, fields declared using references to other types, like <code>foo/Supplier.Active</code>, require those entities to be present when the key is used.</p>
<p>Key fields can be defined with a default value other than <code>nil</code>:</p>
<pre><code class="clojure">     .
     .
   foo/Supplier.Active :as SupplierActive = (enum-val :foo/Active :y)
     .
</code></pre>
<h2><a href="#the-mighty-aggregate-" name="the-mighty-aggregate-"></a>The Mighty (aggregate)</h2>
<p>In any data model there are many relationships between the various entities. When defining a part of the processing model, a subset of those relationships will be navigated to build an appropriate structure, expressing them by the relative positions of the instances: - siblings in a map: 1-to-1 - nested vector: 1-to-many</p>
<p>Consider the following example</p>
<p><img src="aggregate.png" alt="Runtime Structure" title="Relationship Structure" /></p>
<p>The second-level maps allow relationships to be expressed at that level, an so on deeper into the structure.</p>
<p>This structure can be built using <code>aggregate</code> like this:</p>
<pre><code class="clojure">      (-&gt; {}
          (aggregate :to :foo/Fruit :key-val {:Fruit "Strawberry"})
          (aggregate :to :foo/Supplier
                     :from [:Fruit]
                     :instance-name
                     :Supplier
                     :set-name :suppliers
                     :key-val :by-fruit)
          (aggregate :to :foo/Nutrition
                     :from [:Fruit]
                     :for-each (fn bar [v] (assoc v :extra "foo")))
          (aggregate :to :foo/Fruit
                     :for-each (fn foo [v] (assoc v :extra "hello"))
                     :from [:suppliers &gt; :Supplier]
                     :key-val :by-supplier
                     :set-name :fruits))))
</code></pre>
<p>This is saying - starting at the <code>:Fruit</code> Strawberry - aggregate all the suppliers of Strawberry - add in also Strawberry’s associated <code>:Nutrition</code> info and at the same time the additional thing <code>"foo"</code> - aggregate each <code>:Supplier</code>’s inventory of <code>:Fruit</code>s and at the same time the additional thing <code>"hello"</code></p>
<p>The <code>(aggregate data &amp; opts)</code> function is the way to build data graphs from your entity model that express the relationships required by whatever part of the processing model you are currently concerned with.</p>
<p>opts are as follows:</p>
<ul>
  <li>
  <p><code>:from path</code> a vector path to the thing being aggregated from. This is only absent when seeding the structure with its initial value (or vector of values, in the case of a non-unique key). When passing through a vector in the structure indicate this using <code>&gt;</code></p></li>
  <li>
  <p><code>:to type-ref</code> mandatory - the type being joined in the structure.</p></li>
  <li>
  <p><code>:key-val</code> when <code>:from</code> is present, by default it will be used as the value for the target type’s <code>:primary</code> key, however this behaviour is overridden by key-val, which may be either the return value of make-key or a vector tuple of <code>[key-name key-value]</code>, a keyword identifying a known key or a function (see below).</p></li>
  <li>
  <p><code>:instance-name</code> the map key to use when placing single instances in the structure. This applies whether the key being applied is unique or not. The name will be used in all map children housing each instance. Optional and if absent the unqualified name or any alias is used.</p></li>
  <li>
  <p><code>:set-name</code> the map key for the vector returned by non-unique keys when placed in the parent map. Mandatory when a non-unique key is being used, otherwise ignored.</p></li>
  <li>
  <p><code>:merge</code> Any existing value will always be replaced by a new one. In the case of a non-unique key, an existing vector will be replaced unless this option specifies either <code>:primary</code> or a function. The option of <code>:primary</code> will merge current and new values into the result vector by the primary key set. A function must accept three arguments, the instance-name, current and new vectors, and return a vector containing the required merge.</p></li>
  <li>
  <p><code>:must-join</code> If true, when aggregating to a vector, the map child will be removed for any instances that don’t join with the target. Otherwise the vector entry remains with a nil child where there is no join.</p></li>
  <li>
  <p><code>:for-each</code> A function called after the aggregation. Will be passed the parent node and must return the new child.</p></li>
</ul>
<h2><a href="#i-o-mechanisms" name="i-o-mechanisms"></a>I/O Mechanisms</h2>
<p>The <code>entity-sql</code> library implements <code>core</code>’s <code>IO</code> protocol and provides the <code>bind-connection</code> macro to bind entities to SQL databases.</p></div></div></div></body></html>